[переход]
Кхм... Окей... 

Что нас всех объединяет?... Правильно - вопросы! Ими задаются все а в особенности новички, и самый частый из них - как... что-то... изучать...? как пройти от точки А до точки Б максимально быстро и эффективно, этим вопросом когда-то задался я, и решил показать вам, как человек от полного непонимания в определенной сфере может добраться до поставленной им цели... 
[переход]
В качестве подопытного кролика я выбрал язык программирования C 
Краткая справка о нем: 
(C - not four video)Язык разработанный с 1969 по 1973 Деннисом Ритчи сотрудником Bell Labs, C является развитием языка программирования Би. 
C используется везде, начиная с операционных систем(Linux, Windows, MacOS), заканчивая микросхемой  для ракет. В определенных кругах общества программистов, он считается низкоуровневым, хотя является все той же более читаемой абстракцией  над машинным кодом как и assembly. 

Кто-то может задаться вопросом, "Языку почти 52 года, зачем его изучать если есть python, java script и другие более современные языки" -  им отвечу я, что C хоть и является высокоуровневой абстракцией, все равно открывает двери в изучении comp science, а изучение того, с чем ты каждый день активно работаешь и является развитие тебя как инженера. Проведу аналогию с машиной, программист который изучил java script является ее водителем, человек который в свою очередь изучил comp science является архитектором этой машины. 
[переход]
Хорошо, ближе к сути, на первую итерацию изучения я выделил один месяц активного изучения, то есть в день минимум 2 часа я посвящал этому ремеслу. Мой план обучения выглядел следующим образом: 
- Видео на YouTube 
- Алгоритмы 
- Пет-проекты 
Моя цель на первую итерацию была - понять основы синтаксиса языка а так же его возможности, пет-проекты должны были включать в себя понимание низкоуровневых особенностей компьютера, то есть их была у меня двоя: 
- LinkedList 
- и имплементация нативного array(то есть целой ячейки памяти от 0 до N с градацией памяти в зависимости от типа инициализатора) 

И важно: каждый процесс изучения не важно, будь то изучение работы компилятора или операционных систем, должен сопровождаться проектом иначе эта информация быстро выветриться и оставит ощущение упущенного время. 

А решение алгоритмов служила закреплением полученных знаний синтаксиса, кстати, хотите видео про алгоритмы где я раскрою их значимость и отвечу на вопрос: "нужны ли они для программиста?" - если да, то like и основываясь на статистике я выпущу или не выпущу видео 
[переход]
Фух, начинаем, первая неделя(левый угол - 1 неделя): 
Уроки с YouTube, введение в язык и его история, честно на этом этапе я ощущал, что прикасаюсь  к чему-то большему, к чему-то что учит тебя а не запоминаний базовых конструкций.
Далее было установка IDE и плагинов для нее, выбрал я VSCODE, пока все легко и не обременено. 

Движемся дальше, изучение "Hello world!" что может быть легче, думал я, перед началом уроке, в начале автор начал рассказывать про поток выхода информация в контексте приложение, что бы мы могли ввести что то в консоль, оперируя API stdio мы можем записать байт в консоль и считать его из потока входа информации. Байт - может быть без знаковым который вмещает в себя от 0 до 255 число и знаковым, который может содержать от -128 и 127 число. А как компьютер понимает что число содержит знак минус? - все просто, мы находим старший бит в байте и если он 1 то значит число отрицательно иначе число положительное. 

Неплохо для первого полноценного урока, да, расслабьтесь, это только начало)   

А сейчас думаю кто то из вас падет в трепещущий ужас от увиденной записи: 
```C
char symbol = 100; 
```
Здесь мы в переменную типа char записываем целочисленное число, спрашивается как это возможно, если char принимает символ? - все не совсем ытак, тип char является одним байтом который принимает в себя целочисленное обозначение символа в соответствие с символьное таблицой, то есть запись: 
```C
char symbol = 'd'; 
```
и 
```C
char symbol = 100;
```
для компьютера является равноценной. 

Окей, унарные бинарные, тернарные операции и понимание почему данная запись является истинной 
```C
i++ != ++i 
```
в крации расскажу, постфиксный икремент переменной срабатывает после того, как эта переменная была куда-то передана, префиксный инкремент делает ровно наоборот, переменная изначально увеличивается на еденицу а после передается. 

Ну что, начинается одна из самых интересных тем - битовые операции, их четыре: 
&(и), |(или), ~(НЕ) и ^(XOR), 

битовая операция &(и) или же битовое умножение, его можно интерпритировать именно как умножение, ибо поведение схожее: 
бит после преминения данной операция принимает значение 1 только в том случае, если левой операнд имел бит со значеним 1 и правый операнд имел бит со значением 1, остальные же варианты возвращают 0: 
[00000011] & [00011110]
как результат мы получим: [00000010]

дальше, |(или) имя этой битовой операции говорит само за себя, на выходе мы получаем 1 в случаях: если у одного из двух операндов был бит со знаком 1-цы или оба операнда имели бит со знаком 1-цы: 
[00000000] | [00000001] == [00000001] 
[00000001]  | [00000001] == [00000001]

неплохо, но что на счет битовой операции ~(НЕ), ну тут даже легче предыдущих, это унарная операция, которая конвертирует биты операнда: 
~[10011001] == [01100110]

окей, ^(XOR) или же исключающее <<или>>, то есть что бы получить на выходе 1-цу, у одного из операндов должен быть бит с 0 а у другого с 1-цой в ином случае на выходе мы получим 0: 
[00001001] ^ [00000001] == [00001000]

дальше идут операции сдвига битов: >> и << после символа необходимо добавить число которое будет обозначать на сколько бит сдвигать биты, на примере это будет понятнее чем попыткой передать все это словами:: 
(>>) - смещение бит вправо 
[00010100] >> 1 == [00001010]
[00010100] >> 2 == [00000101]

(<<) - смещение бит влево
[00010100] << 1 == [00101000]
[00010100] << 2 == [01010000]

фууух, было интересно, а как на счет случайных чисел? - их в C нет, так как алгоритмы их генерирумые базируються на начальном состоянии регистра и результат возвращают с помощью некого алгоритма, то есть это означает что при повторном запуске программы, сгенерируемое число будет идентичным с предыдущим 

К текущему моменту подошла к концу первая неделя, и хочу сказать, что темы которые поднимаются при изучении C абсолютно различаются по сравнению с другими языками, здесь упор идет именно в comp science а не в изучении фрейморвка или либы. 
[переход]

