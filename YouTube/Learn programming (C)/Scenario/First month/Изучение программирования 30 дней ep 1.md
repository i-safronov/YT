[переход]
Кхм... Окей... 

Что нас всех объединяет?... Правильно - вопросы! Ими задаются все а в особенности новички, и самый частый из них - как... что-то... изучать...? как пройти от точки А до точки Б максимально быстро и эффективно, этим вопросом когда-то задался я, и решил показать вам, как человек от полного непонимания в определенной сфере может добраться до поставленной им цели... 
[переход]
В качестве подопытного кролика я выбрал язык программирования C 
Краткая справка о нем: 
(C - not four video)Язык разработанный с 1969 по 1973 Деннисом Ритчи сотрудником Bell Labs, C является развитием языка программирования Би. 
C используется везде, начиная с операционных систем(Linux, Windows, MacOS), заканчивая микросхемой  для ракет. В определенных кругах общества программистов, он считается низкоуровневым, хотя является все той же более читаемой абстракцией  над машинным кодом как и assembly. 

Кто-то может задаться вопросом, "Языку почти 52 года, зачем его изучать если есть python, java script и другие более современные языки" -  им отвечу я, что C хоть и является высокоуровневой абстракцией, все равно открывает двери в изучении comp science, а изучение того, с чем ты каждый день активно работаешь и является развитие тебя как инженера. Проведу аналогию с машиной, программист который изучил java script является ее водителем, человек который в свою очередь изучил comp science является архитектором этой машины. 
[переход]
Хорошо, ближе к сути, на первую итерацию изучения я выделил один месяц активного изучения, то есть в день минимум 2 часа я посвящал этому ремеслу. Мой план обучения выглядел следующим образом: 
- Видео на YouTube 
- Алгоритмы 
- Пет-проекты 
Моя цель на первую итерацию была - понять основы синтаксиса языка а так же его возможности, пет-проекты должны были включать в себя понимание низкоуровневых особенностей компьютера, то есть их была у меня двоя: 
- LinkedList 
- и имплементация нативного array(то есть целой ячейки памяти от 0 до N с градацией памяти в зависимости от типа инициализатора) 

И важно: каждый процесс изучения не важно, будь то изучение работы компилятора или операционных систем, должен сопровождаться проектом иначе эта информация быстро выветриться и оставит ощущение упущенного время. 

А решение алгоритмов служила закреплением полученных знаний синтаксиса, кстати, хотите видео про алгоритмы где я раскрою их значимость и отвечу на вопрос: "нужны ли они для программиста?" - если да, то like и основываясь на статистике я выпущу или не выпущу видео 
[переход]
Фух, начинаем, первая неделя(левый угол - 1 неделя): 
Уроки с YouTube, введение в язык и его история, честно на этом этапе я ощущал, что прикасаюсь  к чему-то большему, к чему-то что учит тебя а не запоминаний базовых конструкций.
Далее было установка IDE и плагинов для нее, выбрал я VSCODE, пока все легко и не обременено. 

Движемся дальше, изучение "Hello world!" что может быть легче, думал я, перед началом уроке, в начале автор начал рассказывать про поток выхода информация в контексте приложение, что бы мы могли ввести что то в консоль, оперируя API stdio мы можем записать байт в консоль и считать его из потока входа информации. Байт - может быть без знаковым который вмещает в себя от 0 до 255 число и знаковым, который может содержать от -128 и 127 число. А как компьютер понимает что число содержит знак минус? - все просто, мы находим старший бит в байте и если он 1 то значит число отрицательно иначе число положительное. 

Неплохо для первого полноценного урока, да, расслабьтесь, это только начало)   

А сейчас думаю кто то из вас падет в трепещущий ужас от увиденной записи: 
```C
char symbol = 100; 
```
Здесь мы в переменную типа char записываем целочисленное число, спрашивается как это возможно, если char принимает символ? - все не совсем ытак, тип char является одним байтом который принимает в себя целочисленное обозначение символа в соответствие с символьное таблицой, то есть запись: 
```C
char symbol = 'd'; 
```
и 
```C
char symbol = 100;
```
для компьютера является равноценной. 

Окей, унарные бинарные, тернарные операции и понимание почему данная запись является истинной 
```C
i++ != ++i 
```
в крации расскажу, постфиксный икремент переменной срабатывает после того, как эта переменная была куда-то передана, префиксный инкремент делает ровно наоборот, переменная изначально увеличивается на еденицу а после передается. 

Ну что, начинается одна из самых интересных тем - битовые операции, их четыре: 
&(и), |(или), ~(НЕ) и ^(XOR), 

битовая операция &(и) или же битовое умножение, его можно интерпритировать именно как умножение, ибо поведение схожее: 
бит после преминения данной операция принимает значение 1 только в том случае, если левой операнд имел бит со значеним 1 и правый операнд имел бит со значением 1, остальные же варианты возвращают 0: 
[00000011] & [00011110]
как результат мы получим: [00000010]

дальше, |(или) имя этой битовой операции говорит само за себя, на выходе мы получаем 1 в случаях: если у одного из двух операндов был бит со знаком 1-цы или оба операнда имели бит со знаком 1-цы: 
[00000000] | [00000001] == [00000001] 
[00000001]  | [00000001] == [00000001]

неплохо, но что на счет битовой операции ~(НЕ), ну тут даже легче предыдущих, это унарная операция, которая конвертирует биты операнда: 
~[10011001] == [01100110]

окей, ^(XOR) или же исключающее <<или>>, то есть что бы получить на выходе 1-цу, у одного из операндов должен быть бит с 0 а у другого с 1-цой в ином случае на выходе мы получим 0: 
[00001001] ^ [00000001] == [00001000]

дальше идут операции сдвига битов: >> и << после символа необходимо добавить число которое будет обозначать на сколько бит сдвигать биты, на примере это будет понятнее чем попыткой передать все это словами:: 
(>>) - смещение бит вправо 
[00010100] >> 1 == [00001010]
[00010100] >> 2 == [00000101]

(<<) - смещение бит влево
[00010100] << 1 == [00101000]
[00010100] << 2 == [01010000]

фууух, было интересно, а как на счет случайных чисел? - их в C нет, так как алгоритмы их генерирумые базируються на начальном состоянии регистра и результат возвращают с помощью некого алгоритма, то есть это означает что при повторном запуске программы, сгенерируемое число будет идентичным с предыдущим 

К текущему моменту подошла к концу первая неделя, и хочу сказать, что темы которые поднимаются при изучении C абсолютно различаются по сравнению с другими языками, здесь упор идет именно в comp science а не в изучении фрейморвка или либы. 
[переход]

Интересная конструкция языка C  - является дерективы условной компиляции, то есть при добавлении специальных команд в заголовке файла макропроцессор языка C проходиться по этим конструкциям выполняет соответствующие операции, с помощь этого можно сделать что то подобно констант: 
```C
#define SMTH_INT 1

int main(int argc, char** argv)
{
	use_it(SMTH_INT); /*Макропроцессор просто вставит число 1 вместо     SMTH_INT*/
}
```

циклы for, while, do while, оператор goto нечего интересного 

наконец-то, встречайте, бурно обсуждаемые, несущие в себе великие возможности - указатели. 
Указатели являються возможностью прямо манипулировать памятью вашего компьютера, реализуют эту возможность с помощью извините за тавтологию, механизма который может указывать на произвольную ячейку памяти, пример: 
```C
int x = 10; 
int *ptr_x = &x; 
```
переменная ptr_x получает адрес зарезервированной памяти переменной x и может напрямую изменять значение этого адреса: 
```C
ptr_x = 11; 
```
но на уровне машинных кодов, указатель это просто целочисленная переменная, размер который зависит от разрядности процессора, то есть: 
32 - разрядный - 4 байта 
64 - разрядный - 8 байт 

Адресная арифметика,
Представим мы выделили 8 байт памяти, при этом указатель на эти байты мы приводим к типу int, соответсвенно инкрементирование этого указателя сдвинет его на + 4 байта от 0-вой позиции на которую он изначально ссылался. Теперь мы можем подменить тип указателя на любой из доступных и его икриментация будет зависить от количество байт приведенного типа. Окей? - cool 

кстати, вы знали, что null это просто указатель на нулевой в прямом смысле адрес памяти?

[переход]

Окей, как часто вас посещало вдохновение от изучение нового материала? - думаю часто, но утверджаю что это ощущение длилось максимум две недели, а после вы смирились с текущей реальностью и процесс усвоения информации становился больше был похож на пытку чем на приятное занятие. С этим я и столкнулся на третьей неделе, мотивация пропала осталась лишь воля что бы продолжать несмотря ни на что, и многие новички на этом этапе испытывают то же самое, но вместо того, что бы продолжать учиться, они бросают это дело со словами "Это не мое", поймите, этот процесс временный и скоро закончиться, а оставит он вам либо гордость либо разочарование... 

[переход]

Массивы - думаю многие из вас с ними работали, но что вы о них знаете? - правильно, мало что, а их поведение очень схожее с поведением указателя, даже имя массива и является указатель на его первый элемент: 
```C
int arr[10] = {0}; 
int *ptr_arr = arr; 

*ptr_arr == arr[0]; 
```
А так же итерироваться по массиву можно не привычным методом: 
```C
arr[x] 
```
а с помощью арифметики указателей: 
```C
*(arr + index)
```
здесь мы перемещаем указатель на + index позицию, с текущей позиции указателя, и соответственно разыменоваем его. Почему это возможно: 
[0, 1, 2, 3] - индексы 
[0, 0, 0, 0] - ячейки в массиве расположены подобным способом, в памяти компьютера они выглядят так: 
[0x16fdff460, 0x6fdff464, 0x16fdff468] - адреса памяти
[00000000, 00000000,  00000000] - значения массива 
как видно, каждая ячейка(кроме первой) памяти расположена на +4 байта от предыдущей, указатель который ссылается на первую переменную массива, с помощью арифметики указателей просто переходит по ячейкам памяти в зависимости на сколько байт нужно сделать следующий шаг. 

Но что же касается двумерных массивов, вот тут уже интереснее, предположим двумерный массив выглядит так: {} - []
0{0, 1, 2}, 1{0, 1, 2}}
{{0, 0, 0}, {0, 0, 0}}

Что же касается памяти компьютера, то этот же самый двумерный массив будет выглядеть так: 
[0x16fdff460, 0x16fdff464, 0x16fdff468, 0x16fdff472, 0x16fdff476, 0x16fdff480]
[00000000, 00000000,  00000000,  00000000,  00000000,  00000000] 
интересно выглядит, не правда ли? если присмотреться, то здесь нет никаких двумерных массивов, это все тот же одномерный массив расположенный в памяти, именно API массивов позволяет итерироваться по индексам, то есть если мы запишим таку запись: 
```C
arr[x, y] 
```
мы укажем компилятору что нужно сдвинуть указатель на x * sizeof(размер первых элементов), после чего нужно сдвинуть указатель на y что ровняеться: x * sizeof(размер первых элементов) + y * sizeof(тип данных массива)